---
title: "Mosaic in Action"
subtitle: "North Carolina Examples"
author: "Matt Mohn | @mattmxhn"
output:
  pdf_document:
    latex_engine: lualatex
---

Before exploring our examples, we source the Mosaic main .R file, and run `load_mosaic()`.

&nbsp;

```{r setup, results="hide"}
source("mosaic.R")
load_mosaic()
```

```{r trim_file_name_for_render,include=FALSE}
setwd("~/R_Workshop/Git/Mosaic")
```


&nbsp;

For testing, we will use the included `North_Carolina_Simplified.shp` shapefile. This is a generalized (simplified) shapefile of North Carolina's VTD election precincts, with the following attribute columns as well as geographic details. The election data is taken from the 2024 presidential election.

* GEOID20 `<chr>` - a VTD identifier string unique to each precinct
* CTY `<chr>` - a county ID string identifying the precinct's county
* POP `<dbl>` - a numeric count of residents in the precinct
* DEM `<dbl>` - a numeric count of Democratic votes in the precinct
* REP `<dbl>` - a numeric count of Republican votes in the precinct

&nbsp;

```{r set-shapefile}
SHAPEFILE <- "shapefiles/North_Carolina_Simplified.shp"
```


\pagebreak

## Example 1: Simple Annealing

Let's setup and run the chain.

By default, Mosaic will run for 1000 iterations with a `pdev_tolerance` (acceptable population deviation) of +/-5%, and applies a cut edge weight of 1 (`weight_cut_edges` = 1). It will produce 5 districts by default, but we want North Carolina to have the 14 congressional districts it has in real life, so we set `num_districts` to 14 here.

&nbsp;

```{r ex1, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=123456
)

```

&nbsp;

The results of the annealing are encouraging: the program initialized with 792 cuts (which isn't bad itself) and then fell to 540 over the course of the run. 

The score perfectly matches the number of cuts because that's the only weight that we used.

&nbsp;

```{r ex1-graph-silent, echo=FALSE,message=FALSE,warning=FALSE, fig.height=3}

# Get the results from the last run
most_recent_metrics <- list.files("output/", pattern = "^metrics.*\\.csv$", 
                                  full.names = TRUE) |> 
  {\(x) x[which.max(file.mtime(x))]}()

metrics_data <- read_csv(most_recent_metrics)

ggplot(data=metrics_data)+
  geom_line(aes(x=iteration,y=cut_edges),
            linewidth=1,
            color="#254B81")+
  ylab("")+
  labs(title="Cut edges")+
  theme_minimal()

```

&nbsp;

_Knowing_ the results is only a part of the fun. Let's see what the map actually looks like.

Mosaic includes the `mosaic_plot` file, which can create nice-looking maps on the fly.

&nbsp;

```{r ex-1-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

# By default, mosaic_plot will call from the most recently
# saved final_assignments file.

p <- mosaic_plot(shapefile_path = SHAPEFILE,
                 type="simple",
                 title="North Carolina: Example 1",
                 subtitle="Congressional districts, no weights",
                 border_outline = TRUE, 
                 district_outline = TRUE,
                 county_outline = TRUE, 
                 number_labels = TRUE,
                 precinct_outline = TRUE)
p

```

&nbsp;

It looks great! All of the districts are fairly compact and there aren't many weird shapes. One issue jumps out though - we're splitting counties all over the place (look at Charlotte or Raleigh!) That makes sense- we didn't tell Mosaic to try in the first place. For that, let's move to example 2.

&nbsp;

\newpage

## Example 2: Preserving Counties

To better preserve counties, we take the same `run_chain()` call from earlier- but make two critical changes.

- First, we apply `county_bias`. The recombination algorithm usually randomly selects connections in the spanning graph to cut. However, we can induce it to draw cuts _between_ counties, instead of _within_ them, by increasing the sampling probability of edges that are also county boundaries. By setting `county_bias` to 10, we make it 10 times as likely that a county boundary is selected compared to a typical connection.

- Second, although `county_bias` will naturally lead to maps with fewer county splits, we also want the algorithm to try and value low-splitting as a general practice. We set `weight_county_splits` to 15. There are no units involved, but by default this means that 1 county split will be worth as much as 15 additional cut edges in annealing.

&nbsp;

```{r ex2, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=12345,
  county_bias=10,
  weight_county_splits=15,
)

```

&nbsp;

The initial score (954) reflects the number of cut edges (725) plus 10 times the number of county splits (15.3). After 1000 iterations, the score has fallen to 511, with 475 cut edges and just 2.40 county splits.

&nbsp;

```{r ex2-graph-silent, echo=FALSE,message=FALSE,warning=FALSE, fig.height=3}

# Get the results from the last run
most_recent_metrics <- list.files("output/", pattern = "^metrics.*\\.csv$", 
                                  full.names = TRUE) |> 
  {\(x) x[which.max(file.mtime(x))]}()

metrics_data <- read_csv(most_recent_metrics)

# Calculate scaling factor for secondary axis
scale_factor <- max(metrics_data$cut_edges, na.rm = TRUE) / 
                max(metrics_data$county_splits, na.rm = TRUE)

ggplot(data = metrics_data) +
  geom_line(aes(x = iteration, y = cut_edges, color = "Cut Edges"),
            linewidth = 1) +
  geom_line(aes(x = iteration, y = county_splits * scale_factor, color = "County Splits"),
            linewidth = 1) +
  scale_color_manual(
    name = "",
    values = c("Cut Edges" = "#254B81", "County Splits" = "#6BA3D0")
  ) +
  scale_y_continuous(
    name = "Cut Edges",
    sec.axis = sec_axis(~ . / scale_factor, name = "County Splits")
  ) +
  labs(title = "Cut Edges and County Splits") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.title.y.left = element_text(color = "#254B81"),
    axis.text.y.left = element_text(color = "#254B81"),
    axis.title.y.right = element_text(color = "#6BA3D0"),
    axis.text.y.right = element_text(color = "#6BA3D0")
  )
```

&nbsp;

For due diligence's sake, let's plot the map just to be sure.

&nbsp;

```{r ex2-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot(shapefile_path = SHAPEFILE,
                 type="simple",
                 title="North Carolina: Example 2",
                 subtitle="Congressional districts with county weights",
                 border_outline = TRUE, 
                 district_outline = TRUE,
                 county_outline = TRUE, 
                 number_labels = TRUE,
                 precinct_outline = TRUE)
p

```

&nbsp;

Looks good! 

There are different ways of measuring county splits. Four counties are split here (Granville, Mecklenburg, Wake, and Wilkes) but because Meck and Wake are larger than a district each, we subtract them from the total, taking us down to 2.

The remaining 0.4 comes from a measure of fragmentation- this penalizes splits that are especially egregious.

Now that we know how to draw goegraphically nice-looking maps, Example 3 will explore using partisan data.

&nbsp;

\newpage

## Example 3: Republican Gerrymander

For Example 3, let's attempt to draw a Republican gerrymander- which, not coincidentally, is what the North Carolina General Assembly has been doing for the past two decades anyway. Learn from the best, right?

Let's use the following settings:

* Decrease `county_bias` to 2. First off, we care less about county splits this time around. Second, when we're looking to pull off partisan objectives, we don't want to constrain the set of possible combinations available to us.
* Decrease `weight_county_splits` to 5- again, nice to have, but not something mission-critical.
* Increase `num_steps` to 3000 up from the default 1000, to give us more room to maneuver.
* Set `target_efficiency_gap` to 0.5, meaning we aim for Republican votes to be 40% more efficient than Democratic ones. We weight this a 100 using `weight_efficiency_gap`.
* Set `target_mean_median` to 0.15, meaning we want the median district in North Carolina to be 15% more Republican by share of the vote than the state as a whole. If the state votes for a Democrat, we still want a majority to be won by Republicans. We weight this a 50 using `weight_mean_median`.
* Finally, set `target_dem_seats` to 2. This is pretty self-explanatory! We could aim for 0, but that would be very difficult and we don't want the score to be too meaningless. We weight this even further, to 250, using `weight_dem_seats.`

&nbsp;

```{r ex-3, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=123456,
  county_bias=2,
  weight_county_splits=5,
  target_efficiency_gap=0.5,
  weight_efficiency_gap=100,
  target_mean_median=0.15,
  weight_mean_median=50,
  num_steps=3000,
  target_dem_seats=2,
  weight_dem_seats=250
)

```

&nbsp;

The results are encouraging. `MM DIFF` is R+5.0 (not R+15, our target, but pretty good for 3000 runs), and `EG ADJ` (efficiency gap adjusted over a few different swing scenarios) hit R+25.

The model expects Republicans to win 10.5 seats over the long-run average, with Democrats winning only 3.5 - but the seat table makes it pretty clear that in most years this is a 11-3 map.

Once again, we graph using `mosaic_plot` - this time, however, we can set `type` to 'partisan' and look at the districts' final partisanship. This only works if we ran the annealing using partisan data- otherwise the annealing will not store this information.

&nbsp;

```{r ex3-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot(shapefile_path = SHAPEFILE,
                 type="partisan",
                 title="North Carolina: Example 3",
                 subtitle="Republican congressional gerrymander",
                 border_outline = TRUE, 
                 district_outline = TRUE,
                 county_outline = TRUE, 
                 number_labels = TRUE,
                 precinct_outline = FALSE)
p

```

&nbsp;

Anyone familiar with North Carolina gerrymandering history will immediately recognize this kind of map.

* The Triad is cracked; Greensboro and Winston-Salem are put into separate districts. District 1 (the Winston-to-TN district) looks like Virginia Foxx's NC-5 from 2001-2021. Greensboro itself is split perfectly in half.
* Charlotte, Raleigh, Chapel Hill, and Durham are all packed into deep blue districts.
* The Black Belt is split. Goldsboro, Kinston, and Rocky Mount all end up in three different districts.
* Two 'claws' form around the Triangle (Districts 5 and 10) instead of a district forming along the VA border.
* Fayetteville's district reaches south (towards South Carolina). Any other direction would be more purple.
* The purple-ish suburbs around Charlotte end up in three different districts.

All of these choices (major and minor) contribute to this kind of partisan lean, but the algorithm figured out unknowingly what took Republican mapmakers a while to master.

Let's check out the partisan skew using `mosaic_partisan_plot`

&nbsp;

```{r  ex3-graph, results="hide", message=FALSE,warning=FALSE, fig.height=3}
p <- mosaic_partisan_plot(title="Example 3",
                          subtitle="Republican Gerrymander")

p

```

&nbsp;

Gerrymandering in North Carolina is a bipartisan tradition, however, so for the reverse take, check out Example 4.

\newpage

## Example 4: Democratic Gerrymander

For the Democratic attempt, we will basically reverse the settings from Example 3. The changes are:

* Set `target_efficiency_gap` to -0.5, meaning we aim for __Democratic__ votes to be 50% more efficient than Republican ones.
* Set `target_mean_median` to -0.1, meaning we want the median district in North Carolina to be 15% __less__ Republican by share of the vote than the state as a whole.
* Finally, set `target_dem_seats` to 10.

For concision, let's suppress the console output summaries with `verbose_console` = FALSE.

&nbsp;

```{r ex-4, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=123456,
  county_bias=2,
  weight_county_splits=5,
  target_efficiency_gap=-0.3,
  weight_efficiency_gap=100,
  target_mean_median=-0.1,
  weight_mean_median=50,
  num_steps=3000,
  target_dem_seats=11,
  weight_dem_seats=250,
  verbose_console=FALSE 
  
)

```

&nbsp;

The results look great, but in in the opposite direction from earlier. `MM DIFF` is D+8.4, meaning the median district gave Kamala Harris 57.1% of the vote, while the average across the state was just 48.7%.

`EG ADJ` is D+10.7, and the model expects Democrats to win 8.0 seats and Republicans 6.0.

Again, we graph using `mosaic_plot`.

&nbsp;

```{r ex4-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot(shapefile_path = SHAPEFILE,
                 type="partisan",
                 title="North Carolina: Example 4",
                 subtitle="Democratic congressional gerrymander",
                 border_outline = TRUE, 
                 district_outline = TRUE,
                 county_outline = TRUE, 
                 number_labels = TRUE,
                 precinct_outline = FALSE)
p

```

&nbsp;

Here, many of the opposite decisions from the Republican map have been taken.

* Charlotte is cracked in two- not packed. The resulting districts (12 and 6) both vote solidly blue.
* Similarly, the Triangle is cracked- not packed- and its blue votes are distributed into 5 different districts.
* The Piedmont Triad is mostly united in District 10 (with some of Greensboro's excess blue elsewhere). Fayetteville's district aims north to purple Raleigh suburbs, not east.

On the Tennessee border, Mosaic sees a chance at a competitive district, and while it can't draw a blue one, it follows the ghost of Heath Shuler to come up with one (District 4) that Trump only won by 7 points.

&nbsp;

```{r  ex4-graph, results="hide", message=FALSE,warning=FALSE, fig.height=3}
p <- mosaic_partisan_plot(title="Example 4",
                          subtitle="Democratic Gerrymander")

p

```


\newpage

## Example 5: A Fair State Senate Map

Let's deploy the partisan tools for a good cause- drawing a fair/competitive North Carolina State Senate map.

* Switch `target_mean_median` to 0 and `target_efficiency_gap` to 0. This is the same as favoring neither party.
* Introduce `weight_competitiveness` to 15. This metric tries to increase the share of districts that are competitive, where a 100% competitive district is defined as having a 50/50 chance of going to either party.
* Bolster our county tools, like `county_bias` and `weight_county_splits` - since we're after noble causes now.

&nbsp;


```{r ex-5, message=FALSE,warning=FALSE, size = "small"}

results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 50,
  seed=123456,
  county_bias=5,
  weight_county_splits=10,
  target_mean_median=0,
  weight_mean_median=150,
  target_efficiency_gap=0,
  weight_efficiency_gap=100,
  weight_competitiveness=5,
  num_steps=5000,
  verbose_console = FALSE
)

```

&nbsp;

The results are compelling.

* The mean Democratic vote share (using Kamala Harris' 2024 result) is 48.7%, and the median is 48.9%. Trump wins a majority of districts, but if Harris had won, she likely would have too.
* The efficiency gap is R+2.1%, well within our tolerance.
* 9.3 competitive seats are forecast- almost 20% of the total map- creating a wide battleground.

&nbsp;


```{r ex5-graph-silent, results="hide",message=FALSE,warning=FALSE, fig.height=3}
p <- mosaic_partisan_plot(title="Example 5",
                          subtitle="Fair NC State Senate")

p

```

... and visualize! Note- in reality, this map would not pass the extremely strict splitting laws that North Carolina has in place for the NCGA. But it's fun to imagine.

&nbsp;

```{r ex5-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot(shapefile_path = SHAPEFILE,
                 type="partisan",
                 title="North Carolina: Example 5",
                 subtitle="Balanced and competitive NC Senate map",
                 border_outline = TRUE, 
                 district_outline = TRUE,
                 county_outline = TRUE, 
                 number_labels = FALSE,
                 precinct_outline = FALSE)
p

```


\newpage

## Example 6: Dealing with Incumbents

Let's imagine that tomorrow a court orders that North Carolina draw a new, fair congressional map. _However_, the court orders that the remedial map try and keep incumbents apart.

Mosaic can help here. The program can handle both pro-bunking and anti-bunking lists. Pro-bunking lists aim to keep precincts together (like communities of interest). Anti-bunking lists aim to keep precincts apart (like incumbent homes).

We establish the incumbent list here. These are the precinct IDs (GEOIDs) for each North Carolina congressperson (roughly - we don't really know where they live). The first two values are the weight and the exponent (here, we go with 1000 and 1 respectively).

&nbsp;

```{r ex6-inc-list}
NC_incumbent_list <- c(
  1000,              # Weight: heavy penalty for splitting
  1,                 # Exponent: linear penalty
  "3707900BEAR", #Davis
  "37183001-27", #Ross
  "3714701504A", #Murphy
  "3713500000H", #Foushee
  "37011000002", #Foxx
  "37059000013", #McDowell
  "37129000W25", #Rouzer
  "37179000014", #Harris
  "37125000SSP", #Hudson
  "37035000013", #Harrigan
  "370890000FR", #Edwards
  "37119000011", #Adams
  "37183001-36", #Knott
  "3704500KM-N"  #Moore
)
```

&nbsp;

We pass the bunking list by adding a call to `create_bunking_lists()` to `run_chain()`. Multiple sub-lists can be added to either `anti_bunking` or `pro_bunking`.

&nbsp;

```{r ex6, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=123456,
  county_bias=3,
  weight_county_splits=15,
  target_mean_median=0,
  weight_mean_median=500,
  target_efficiency_gap = 0,
  weight_efficiency_gap = 100,
  num_steps=2500,
  verbose_console = FALSE,
  verbose_initialization = FALSE,
  bunking_lists = create_bunking_lists(
    anti_bunking  = list(NC_incumbent_list) 
  )
)
```

&nbsp;

Partisanship looks good. No major mean/median skew, and a healthy number of competitive districts.

&nbsp;

```{r ex6-graph-silent, results="hide",message=FALSE,warning=FALSE, fig.height=3}
p <- mosaic_partisan_plot(title="Example 6",
                          subtitle="Fair NC Congressional Map")

p

```

&nbsp;

We can also pass bunking lists to `mosaic_plot()` - which makes it easy to visually check out the results. Each location will appear as a diamond.

&nbsp;

```{r ex6-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot("shapefiles/North_Carolina_Simplified.shp",
                 bunking_lists = create_bunking_lists(
                   anti_bunking  = list(NC_incumbent_list)
                 ),
                 title = "Example 6: Fair NC Congressional Map Without Double-Bunking",
                 subtitle = "Yellow diamonds: incumbent locations",
                 district_outline = TRUE,
                 number_labels = TRUE,
                 county_outline = TRUE,
                 border_outline = TRUE)
p

```

&nbsp;

Not too shabby. The console report told us that the 14 precincts in Anti-Bunking List 1 were saved in 13 districts, and that seems apparent here (although some of them are right on the border). Foxx and Harrigan are both placed in NC-9, but it's a hard prospect to avoid. NC Republicans are stacked on the west of the state because Foxx and Harrigan live on the far west sides of their current (real) districts. 

Tim Moore (speaker of the NC House) didn't help this problem when he essentially drew his own district on that side of the state, and he lives in Kings Mountain.

\newpage

## Example 7: Communities of Interest

In Example 6, we learned that Mosaic includes an anti-bunking functionality to incentivize keeping specific precincts apart (for instance, incumbents). However, Mosaic can also aim to _keep_ precincts together - which can be used to create communities of interest.

There are 17 universities in the University of North Carolina system, scattered from UNC Wilmington on the Atlantic to ASU in the Appalachians. We initialize `NC_university_list` by putting all 17 universities' precincts' GEOIDs together, and weight this pro-bunking list at 5000.

&nbsp;

```{r ex7-inc-list}
NC_university_list <- c(
  5000,              # Weight: heavy bias in favor of grouping
  1,                 # Exponent: linear penalty
  "37183004-05", #NC State
  "37063000047", #NC Central
  "37063000007", #NCSSM
  "37135000UNC", #UNC Chapel Hill
  "37081000G44", #NC A&T
  "37081000G64", #UNC Greensboro
  "37067000403", #Winston-Salem State
  "37067000705", #UNCSA
  "37189000012", #Appalachian State
  "370210010.1", #UNC Asheville
  "37099000RIV", #Western Carolina
  "37119000126", #UNC Charlotte
  "37155000017", #UNC Pembroke
  "3705100CC34", #Fayetteville State 
  "37129000W31", #UNC Wilmington
  "37147001506", #Eastern Carolina
  "3713900EAST" #Elizabeth City State
)
```

&nbsp;

Again, we pass the bunking list by adding a call to `create_bunking_lists()` to `run_chain()`. This time, we add it to the `pro_bunking` list, and let it rip.

&nbsp;

```{r ex7, message=FALSE,warning=FALSE, size = "small"}
results <- run_chain(
  shapefile_path = SHAPEFILE,
  num_districts = 14,
  seed=123456,
  county_bias=1.5,
  weight_county_splits=5,
  target_mean_median=0,
  weight_mean_median=500,
  num_steps=2500,
  verbose_console = FALSE,
  verbose_initialization = FALSE,
  bunking_lists = create_bunking_lists(
    pro_bunking  = list(NC_university_list) 
  )
)
```

&nbsp;

A mean/median difference of R+0.9% isn't that bad, but since this is mostly a COI proof of concept, let's check out the map and see how Mosaic did at keeping the UNC system together.

&nbsp;

```{r ex7-map, warning=FALSE, message=FALSE, results="hide", dpi=150}

p <- mosaic_plot("shapefiles/North_Carolina_Simplified.shp",
                 bunking_lists = create_bunking_lists(
                  pro_bunking  = list(NC_university_list) 
                 ),
                 title = "Example 7: Fair NC Congressional Map Grouping the UNC System",
                 subtitle = "Blue diamonds: institution locations",
                 district_outline = TRUE,
                 number_labels = TRUE,
                 county_outline = TRUE,
                 border_outline = TRUE)
p

```

&nbsp;

Excellent! The console output let us know that these 17 precincts (1 for each school) ended up in 6 different districts, and we verify that visually here.

* District 8 grabs ASU, WCU, and UNC Asheville by stretching up the TN border
* All four Triad institutions (UNCSA, UNCG, NC A&T, WSSU) end up in District 13.
* All four in the Triangle (UNC, NC State, NCCU, and NCSSM) end up in District 9.
* UNC Pembroke, UNC Wilmington, and Fayetteville State are kept in District 4.
* ECU and Elizabeth City State are paired in District 14.

Only one school (UNC Charlotte) ends up on its own, which is part tough luck and part a consequence of where it is geographically.